package io.github.occultus73.firebase.data

import android.app.Application
import android.net.Uri
import android.os.Handler
import android.webkit.MimeTypeMap
import android.widget.Toast
import androidx.lifecycle.MutableLiveData
import androidx.room.Room
import com.google.android.gms.tasks.Task
import com.google.firebase.database.DataSnapshot
import com.google.firebase.database.DatabaseError
import com.google.firebase.database.FirebaseDatabase
import com.google.firebase.database.ValueEventListener
import com.google.firebase.storage.FirebaseStorage
import com.google.firebase.storage.StorageReference
import io.github.occultus73.firebase.data.model.Upload
import io.github.occultus73.firebase.data.room.UploadsRoomDB

// A repository is kind of like the ViewModel for all ViewModels huh?
class FirebaseRepository private constructor(private val application: Application) {
    // Alternative Singleton pattern, where you would otherwise want to pass parameters to an object
    companion object {
        private var INSTANCE: FirebaseRepository? = null
        fun getInstance(application: Application) =
            INSTANCE ?: FirebaseRepository(application).also { INSTANCE = it }
    }

    // Firebase Database & Storage
    private val mStorageInstance = FirebaseStorage.getInstance()
    private val mDatabaseInstance = FirebaseDatabase.getInstance()
    private val mStorageRef = mStorageInstance.getReference("uploads")
    private val mDatabaseRef = mDatabaseInstance.getReference("uploads")

    // Room Database
    private val uploadsRoomDB =
        Room.databaseBuilder(application, UploadsRoomDB::class.java, "uploads.db")
            .allowMainThreadQueries().build()
    private val uploadsDAO = uploadsRoomDB.getUploadsDAO()

    // Toast & Progress Message Channels
    val liveToast: MutableLiveData<String> = MutableLiveData()
    val liveProgress: MutableLiveData<Int> = MutableLiveData()

    // Synchronize Firebase with Room
    init {
        mDatabaseRef.addValueEventListener(object : ValueEventListener {
            override fun onCancelled(error: DatabaseError) {
                liveToast.value = error.message
            }

            override fun onDataChange(snapshot: DataSnapshot) {
                val uploads: MutableList<Upload> = mutableListOf()
                for(uploadSnapshot in snapshot.children){
                    uploadSnapshot.getValue(Upload::class.java)?.let {
                        uploads.add(it)
                    }
                }
                uploadsDAO.resetRoom() // Ugly solution.
                uploadsDAO.insertAllUploads(uploads)
            }
        })
    }

    fun delete(upload: Upload) {
        val imageRef = mStorageInstance.getReferenceFromUrl(upload.mImageUrl)
        imageRef.delete().addOnSuccessListener { mDatabaseRef.child(upload.mID).removeValue() }
        uploadsDAO.deleteUpload(upload)
    }

    fun getAllLocalUploads() = uploadsDAO.getAllUploads()

    //TODO: refactor into WorkManager
    fun uploadImageFileToFirebaseStorage(mImageUri: Uri, requestedFileName: String): Task<Uri> {
        // Configure desired remote name for the image file
        val fileReference: StorageReference = mStorageRef.child(
            System.currentTimeMillis().toString() + "." + getFileExtension(mImageUri)
        )

        //Begin the upload task
        return fileReference.putFile(mImageUri).addOnFailureListener { exception ->
            liveToast.value = exception.message

            //Data for the progress bar
        }.addOnProgressListener { taskSnapshot ->
            val progress = 100.0 * taskSnapshot.bytesTransferred / taskSnapshot.totalByteCount
            liveProgress.value = progress.toInt()

            //Get the new public url of the image
        }.continueWithTask {
            if (!it.isSuccessful) {
                liveToast.value = it.exception?.message ?: "?!?!"
            }
            fileReference.downloadUrl

            //Store the image link on the database
        }.addOnCompleteListener { task ->
            Handler().postDelayed({ liveProgress.value = 0 }, 500)

            if (task.isSuccessful) {
                //this id generated by Firebase will be our primary key in Room
                val uploadId: String = mDatabaseRef.push().key ?: throw Exception("Database: No ID")
                val downloadUri = task.result
                val upload = Upload(uploadId, requestedFileName, downloadUri.toString())

                mDatabaseRef.child(uploadId).setValue(upload)
                liveToast.value = "Upload: $uploadId"
            } else {
                liveToast.value = task.exception?.message ?: "!?!?"
            }
        }
    }

    // just remember dat dis ist just to get the Extension of the File and dat ist it.
    private fun getFileExtension(uri: Uri): String {
        val mime: MimeTypeMap = MimeTypeMap.getSingleton()
        return mime.getExtensionFromMimeType(application.contentResolver.getType(uri))
            ?: throw Exception("bad file type")
    }
}